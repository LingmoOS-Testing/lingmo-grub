---
 grub-core/kern/efi/efi.c      |   78 ++++++++++++++++++++++++++++++++++++++++++
 grub-core/loader/i386/linux.c |    2 +
 include/grub/efi/efi.h        |    4 ++
 3 files changed, 84 insertions(+)

Index: grub2-2.02~beta2/grub-core/kern/efi/efi.c
===================================================================
--- grub2-2.02~beta2.orig/grub-core/kern/efi/efi.c
+++ grub2-2.02~beta2/grub-core/kern/efi/efi.c
@@ -211,14 +211,16 @@ grub_efi_set_variable(const char *var, c
   return grub_error (GRUB_ERR_IO, "could not set EFI variable `%s'", var);
 }
 
-void *
-grub_efi_get_variable (const char *var, const grub_efi_guid_t *guid,
-		       grub_size_t *datasize_out)
+static void *
+get_variable (const char *var, const grub_efi_guid_t *guid,
+	      grub_efi_uint32_t *attributes_out,
+	      grub_size_t *datasize_out)
 {
   grub_efi_status_t status;
   grub_efi_uintn_t datasize = 0;
   grub_efi_runtime_services_t *r;
   grub_efi_char16_t *var16;
+  grub_efi_uint32_t attributes;
   void *data;
   grub_size_t len, len16;
 
@@ -234,7 +236,7 @@ grub_efi_get_variable (const char *var,
 
   r = grub_efi_system_table->runtime_services;
 
-  status = efi_call_5 (r->get_variable, var16, guid, NULL, &datasize, NULL);
+  status = efi_call_5 (r->get_variable, var16, guid, &attributes, &datasize, NULL);
 
   if (!datasize)
     return NULL;
@@ -246,7 +248,7 @@ grub_efi_get_variable (const char *var,
       return NULL;
     }
 
-  status = efi_call_5 (r->get_variable, var16, guid, NULL, &datasize, data);
+  status = efi_call_5 (r->get_variable, var16, guid, &attributes, &datasize, data);
   grub_free (var16);
 
   if (status == GRUB_EFI_SUCCESS)
@@ -259,6 +261,39 @@ grub_efi_get_variable (const char *var,
   return NULL;
 }
 
+void *
+grub_efi_get_boot_variable (const char *var, const grub_efi_guid_t *guid,
+		            grub_size_t *datasize_out)
+{
+  grub_efi_uint32_t attributes;
+  void *data;
+
+  data = get_variable (var, guid, &attributes, datasize_out);
+  if (data)
+    {
+      /* Try to ensure the variable we are retrieving has not been written
+       * from a running system by the user, it should be done by MokManager.
+       */
+      if (attributes & ~GRUB_EFI_VARIABLE_RUNTIME_ACCESS)
+	return data;
+
+      grub_printf ("Found insecure variable.");
+      *datasize_out = 0;
+      grub_free (data);
+    }
+
+  return NULL;
+}
+
+void *
+grub_efi_get_variable (const char *var, const grub_efi_guid_t *guid,
+		       grub_size_t *datasize_out)
+{
+  grub_efi_uint32_t attributes;
+
+  return get_variable (var, guid, &attributes, datasize_out);
+}
+
 grub_efi_boolean_t
 grub_efi_secure_boot (void)
 {
@@ -287,6 +322,27 @@ grub_efi_secure_boot (void)
   return ret;
 }
 
+grub_efi_boolean_t
+grub_efi_unsigned_kernels (void)
+{
+  grub_efi_guid_t efi_var_guid = SHIM_LOCK_GUID;
+  grub_size_t datasize;
+  char *unsigned_kernels = NULL;
+  grub_efi_boolean_t ret = 0;
+
+  unsigned_kernels = grub_efi_get_boot_variable ("MokUnsignedKernels", &efi_var_guid, &datasize);
+
+  if (datasize != 1 || !unsigned_kernels)
+    goto out;
+
+  if (*unsigned_kernels)
+    ret = 1;
+
+ out:
+  grub_free (unsigned_kernels);
+  return ret;
+}
+
 #pragma GCC diagnostic ignored "-Wcast-align"
 
 /* Search the mods section from the PE32/PE32+ image. This code uses
Index: grub2-2.02~beta2/grub-core/loader/i386/linux.c
===================================================================
--- grub2-2.02~beta2.orig/grub-core/loader/i386/linux.c
+++ grub2-2.02~beta2/grub-core/loader/i386/linux.c
@@ -721,6 +721,8 @@ grub_cmd_linux (grub_command_t cmd __att
 		  return GRUB_ERR_NONE;
 		}
 	      grub_dprintf ("linux", "linuxefi failed (%d)\n", grub_errno);
+	      if (!grub_efi_unsigned_kernels ())
+		goto fail;
 	      grub_errno = GRUB_ERR_NONE;
 	    }
 	}
Index: grub2-2.02~beta2/include/grub/efi/efi.h
===================================================================
--- grub2-2.02~beta2.orig/include/grub/efi/efi.h
+++ grub2-2.02~beta2/include/grub/efi/efi.h
@@ -64,6 +64,9 @@ grub_err_t EXPORT_FUNC (grub_efi_set_vir
 							   grub_efi_uintn_t descriptor_size,
 							   grub_efi_uint32_t descriptor_version,
 							   grub_efi_memory_descriptor_t *virtual_map);
+void *EXPORT_FUNC (grub_efi_get_boot_variable) (const char *variable,
+						const grub_efi_guid_t *guid,
+						grub_size_t *datasize_out);
 void *EXPORT_FUNC (grub_efi_get_variable) (const char *variable,
 					   const grub_efi_guid_t *guid,
 					   grub_size_t *datasize_out);
@@ -73,6 +76,7 @@ EXPORT_FUNC (grub_efi_set_variable) (con
 				     void *data,
 				     grub_size_t datasize);
 grub_efi_boolean_t EXPORT_FUNC (grub_efi_secure_boot) (void);
+grub_efi_boolean_t EXPORT_FUNC (grub_efi_unsigned_kernels) (void);
 int
 EXPORT_FUNC (grub_efi_compare_device_paths) (const grub_efi_device_path_t *dp1,
 					     const grub_efi_device_path_t *dp2);
Index: grub2-2.02~beta2/grub-core/loader/i386/efi/linux.c
===================================================================
--- grub2-2.02~beta2.orig/grub-core/loader/i386/efi/linux.c
+++ grub2-2.02~beta2/grub-core/loader/i386/efi/linux.c
@@ -41,9 +41,6 @@ static char *linux_cmdline;
 
 #define BYTES_TO_PAGES(bytes)   (((bytes) + 0xfff) >> 12)
 
-#define SHIM_LOCK_GUID \
-  { 0x605dab50, 0xe046, 0x4300, {0xab, 0xb6, 0x3d, 0xd8, 0x10, 0xdd, 0x8b, 0x23} }
-
 struct grub_efi_shim_lock
 {
   grub_efi_status_t (*verify) (void *buffer, grub_uint32_t size);
Index: grub2-2.02~beta2/include/grub/efi/api.h
===================================================================
--- grub2-2.02~beta2.orig/include/grub/efi/api.h
+++ grub2-2.02~beta2/include/grub/efi/api.h
@@ -286,6 +286,11 @@
       { 0x8B, 0x8C, 0xE2, 0x1B, 0x01, 0xAE, 0xF2, 0xB7 } \
   }
 
+#define SHIM_LOCK_GUID \
+  { 0x605dab50, 0xe046, 0x4300, \
+      { 0xab, 0xb6, 0x3d, 0xd8, 0x10, 0xdd, 0x8b, 0x23 } \
+  }
+
 struct grub_efi_sal_system_table
 {
   grub_uint32_t signature;
